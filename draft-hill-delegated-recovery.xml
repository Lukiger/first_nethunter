<?xml version='1.0' encoding='ascii'?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<rfc category="std" docName="draft-hill-delegated-recovery" obsoletes="" updates="" submissionType="IETF" xml:lang="en">
  <front>
    <title abbrev="Delegated Account Recovery">Delegated Account Recovery</title>
    <author fullname="Brad Hill" initials="B" role="editor" surname="Hill">
      <organization>Facebook, Inc.</organization>
      <address>
        <email>hillbrad@fb.com</email>
      </address>
    </author>
    <date year="2017" month="April" day="12"/>
    <workgroup>Facebook, Inc.</workgroup>
    <abstract>
      <t>Delegated Account Recovery allows an application to delegate the capability to recover an account (e.g. in the event of a credential loss or compromise) to an account controlled by the same user or entity at a third party service provider.</t>
    </abstract>
  </front>
  <middle>
    <section title="Introduction" toc="default">
      <section title="Notational Conventions" toc="default">
        <t>In this document, the key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" are to be interpreted as described in BCP 14, RFC 2119 <xref target="RFC2119" pageno="false" format="default"/>.</t>
        <section title="Presentation Language" toc="default">
          <t>This document deals with the formatting of tokens in an external representation using a casually defined syntax drawing from that used in <xref target="RFC5246" pageno="false" format="default"/> and resembling the programming language "C". The purpose is to document the binary token format only.</t>
          <t>The basic numeric data type is an unsigned byte (uint8). All larger numeric data types are formed from fixed-length series of bytes concatenated from left to right and are also unsigned. The following numeric types are predefined.</t>
          <figure title="" suppress-title="false" align="left" alt="" width="" height="">
            <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
        uint8 uint16[2];
        uint8 uint32[4];
        uint8 uint64[8];
            </artwork>
          </figure>
          <t>All values, here and elsewhere in the specification, are stored in network byte (big-endian) order; the uint32 represented by the hex bytes 01 02 03 04 is equivalent to the decimal value 16909060.</t>
          <t>The type string is defined as a concatenated sequence of octet sequences representing ASCII characters, one per octet.  <xref target="RFC3629" pageno="false" format="default"/></t>
          <t>The term URL is defined by reference to <xref target="RFC3986" pageno="false" format="default"/> in this document. "URL" is used deliberately in preference to "URI" as all such objects in this document are used to access network resources and such objects as used by this document lack any persistent meaning after the resource to which they refer ceases to exist.</t>
        </section>
      </section>
      <!--Notational Conventions -->
      <section title="Challenges with Existing Account Recovery Solutions" toc="default">
        <t>Network services that rely on user credentials must also cope with the reality that users may forget or lose exclusive control of these credentials. As a consequence, nearly every such service must implement an alternate authentication process to enable a user to recover control of an account. In practice, there are few good options for doing this, and these recovery flows are often the weakest link in securing accounts.</t>
        <section title="Recovery Questions" toc="default">
          <t>A common and self-contained method of account recovery is to ask the user additional questions that they are less likely to forget the answer to than a more arbitrary password. The same features that make such a question useful for recovery also reduce its security: <list style="symbols"><t>Things that are memorable may often not be fully private.  Friends and family members likely know the answers to many such questions, and for highly public figures it may be possible to research this information.</t><t>Allowing users to select their own questions may result in questions with a small possible domain of answers (favorite color, favorite superhero) that make brute force guessing highly effective, even if rate-limiting is applied.</t><t>Choosing questions that are both secure and memorable is difficult, and common choices of subject matter may not be applicable across cultural contexts (mother's maiden name, name of a pet), age ranges (first car) or other differentiating characteristics of large and diverse audiences.</t><t>The limited selection of questions which are both memorable and applicable to the broadest possible audience makes re-use of these questions and answers common among many service providers, with attendant risks that disclosure of answers to a malicious party by any provider may compromise many accounts at unrelated providers. Furthermore it is difficult for a user to change their answers in the event of such a compromise.</t></list></t>
        </section>
        <!--Recovery Questions -->
        <section title="Password Hints" toc="default">
          <t>Password hints are extremely problematic - by definition they must be revealed to an unauthenticated user, which implies reversibly encrypted storage at best, reveals information about a password (or often the password itself), and common hints at multiple services may reveal where a password is reused, facilitating further attacks.</t>
        </section>
        <!--Password Hints -->
        <section title="Email Recovery" toc="default">
          <t>Users are unlikely to forget their email address, and a common practice is to email the user URL that encodes the ability to recover the account. This is the most widely deployed mechanism at the time of this writing, but it has a number of shortcomings.  <list style="symbols"><t>Forcing users to everywhere use an email address has privacy implications, potentially allowing service providers to collude to track individuals' activity across many domains.</t><t>Email addresses are not universal, and are becoming less so.  Especially in the developing world or with younger audiences, email may not be the first network service individuals provision for themselves, if they provision it at all.</t><t>Email addresses get recycled and reassigned to new owners.</t><t>Users may use a weakly-secured email addresses when signing up for a new service, for example an address maintained to collect the unwanted commercial correspondence often expected to result from signing up for a new online service.</t><t>Email does not provide guarantees of deliverability or end-to-end transport security. An adversary performing pervasive surveillance may likely be able to abuse such weaknesses.</t><t>Emails in large organizations are rarely private to their recipient. In addition to the commonplace that high-value accounts belonging to executives may be accessible by their assistants, the contents and especially links in the email of every user in a modern organization may commonly be logged for legal discovery purposes, or crawled to identify malware and phishing attacks.</t><t>The capabilities of an emailed reset link must be encoded in the GET string to ensure compatibility with non-HTML capable mail user agents, and so may leak in the HTTP Referer header to any other content included in a recovery page. (e.g. an analytics script hosted at a third-party origin)</t><t>Users are commonly authenticated to email services all the time on many devices. Account recovery through email is an unstructured process which does not ensure the user was strongly authenticated for a high-risk action. A simple password compromise, or even brief loss of control of an unlocked device where the user is logged in, may be sufficient to transitively compromise many other accounts of the user. If the only way to notify the user that their account was reset is back through the same email channel, an attacker can easily cover their tracks.</t><t>The wide diversity of mail user agents means that even if account recovery emails could be detected heuristically by providers or explicitly identified with metadata from senders, it would be remain difficult for email providers to apply special treatment to such messages.</t><t>An attacker that compromises a user's account may change the email address associated with it. Without very carefully designed processes, it may be impossible for the genuine user to recover their account after such a change if recovery flows are purely email-based.</t><t>Email recovery flows cannot be used to recover capabilities, such as cryptographic keys, that may be necessary to use an account (e.g. a network-based file store that offers encrypted files) but which the user does not want the account provider to have access to at all times.</t></list></t>
        </section>
        <!--Email Recovery -->
        <section title="Federated Authentication" toc="default">
          <t>Federated systems for authentication take many forms and solve the problem of account recovery (or at least delegate it implicitly to the Identity Provider). However, after fifteen years of widespread deployment of such systems, we see few mainstream services that are willing to rely exclusively on federated logins for a variety of reasons.  <list style="symbols"><t>A user may be unwilling to disclose their identity, other information, or grant permissions to a new service they have just begun to use and about which they have not yet formed an opinion of its value or trustworthiness.</t><t>A service may be unwilling to depend on a third-party for access to its customer base. They may view "owning" their relationship with the customer as having business value, may have a regulatory mandate to do so, or may not want to be beholden to the availability of a third party for their most important customer interactions.</t><t>A service may view providers of federated login services as competitors or potential competitors, and not wish to disclose information about how often users are logging on, who their most active users are or not desire to show a competitor's logo as part of their login process.</t></list></t>
        </section>
        <!--Federated Authentication -->
        <section title="Alternate Methods" toc="default">
          <t>Methods do exist to strongly re-authenticate an account holder in the absence of a password or other primary credential.  Device-based or multi-factor authentication, multi-device authentication, or trusted connections in a social network are possibilities.  Unfortunately, of the potentially hundreds of services a user interacts with in a year, only a few are likely able to leverage such factors. The rest will lack the information, resources, and user consent needed. Furthermore, the characteristics that make good recovery systems strong also may make them unique to a particular service, preventing broad adoption as a best practice by other providers.</t>
        </section>
        <!--Alternate Methods -->
      </section>
      <!--Challenges with Existing Account Recovery Solutions -->
      <section title="Relationship to Other Protocols" toc="default">
        <t>Delegated Recovery is similar in some respects to OAuth <xref target="RFC5849" pageno="false" format="default"/>and related protocols.</t>
        <t>It is not constructed simply as a profile of one these protocols as it relies on different trust semantics. Because tokens granting an account recovery capability are expected to have an indefinite lifetime and should be able to remain valid even following the compromise and/or rotation of the keys they were originally issued under, tokens in this protocol derive their authority at a point in time from being signed with currently published public keys, discoverable over HTTPS.</t>
        <t>As this trust model is different than other protocols in the broad OAuth family, profiling an existing protocol to fit these needs would likely be considerably more complex than implementing a new, minimalist protocol from scratch. As such, the latter approach has been taken here.</t>
      </section>
      <!--Relationship to Other Protocols -->
      <section title="Goals" toc="default">
        <t>Goals for Delegated Account Recovery include: <list style="symbols"><t>Allow network services that do not have the resources or information to build a secure and usable account recovery process to delegate the function to network services that can.</t><t>Allow users to choose to use service providers that can strongly re-authenticate them to recover accounts at other services.</t><t>Disclose as little information as possible, and no more than is necessary, to protocol participants.</t><t>As much as possible, require multiple points of failure in order for accounts to be compromised through the recovery process.</t><t>Be resilient in the face of compromises, including loss of exclusive control of cryptographic key material, and allow re-establishment of trust in stored recovery capabilities without user action.</t><t>Provide, through the protocol semantics, explicit information about security-critical account actions and information flow between providers to enable better auditing, anomaly detection and remediation in the event of compromises.</t><t>Allow users to set up a durable recovery capability when in control of their account, which can be exercised even after malicious changes to the account (such as changing an associated email address or personal information) following a compromise.</t></list></t>
      </section>
      <!--Goals -->
      <section title="Roles" toc="default">
        <t>Delegated Recovery defines three roles: <list style="hanging"><t hangText="User"><vspace blankLines="0"/>The entity in control of the accounts.</t><t hangText="Account Provider"><vspace blankLines="0"/>The network service at which a user has an account they need to establish a recovery capability for.</t><t hangText="Recovery Provider"><vspace blankLines="0"/>The network service which offers the delegated account recovery service, and at which a user has an account and wishes to use to recover control of other accounts.</t></list></t>
      </section>
      <!--Roles -->
      <section title="Protocol Flow" toc="default">
        <section title="Establishing a Delegated Recovery Capability" toc="default">
          <figure title="Figure 1: Recovery Capability Establishment" suppress-title="false" align="left" alt="" width="" height="">
            <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">

   +--------+           +------+          +----+---+
   |Account |           | User |          |Recovery|
   |Provider|           |      |          |Provider|
   |        |           |      |          |        |
   +-+------+           +--+---+          +----+---+
     |                     |                   |
     | 1. Select Recovery  |                   |
     | Provider            |                   |
     |&lt;--------------------+                   |
     |                     | 2. Retrieve       |
     |                     | Configuration     |
     +----------------------------------------&gt;|
     |&lt;----------------------------------------+
     |                     |                   |
+----+ 3. Generate Recovery|                   |
|    | Token               |                   |
+---&gt;|                     |                   |
     |                     |                   |
     | 4. Redirect User    |                   |
     | Agent to Recovery   |                   |
     | Provider with Token |                   |
     +--------------------&gt;+------------------&gt;|
     |                     |                   |
     |                     | 5. (if needed)    |
     |                     | Authenticate User |
     |                     |&lt;------------------+
     |                     +------------------&gt;|
     |                     |                   |
     |                     | 6. Retrieve       |
     |                     | Configuration     |
     |&lt;----------------------------------------+
     +----------------------------------------&gt;|
     |                     |                   |
     | (optional)          | 7. Verify and     +---+
     | 8. Notify Account   | Save Recovery     |   |
     | Provider with       | Token             |&lt;--+
     | Result Code for     |                   |
     | token ID            |                   |
     |&lt;----------------------------------------+
     |                     |                   |
     | 9. Redirect User    |                   |
     | Agent back to       |                   |
     | Account Provider    |                   |
     |                     |                   |
     |&lt;--------------------+&lt;------------------+
     |                     |                   |
     |                     |                   |
     V                     V                   V


</artwork>
          </figure>
          <t>The abstract Delegated Recovery capability establishment flow illustrated in Figure 1 describes the interaction between the three roles and includes the following steps: <list style="numbers"><t>The User, having already established control of an account with the Account Provider, indicates to the Account Provider which Recovery Provider they would like to use.</t><t>The Account Provider makes a GET request to determine if the service of the user's choice offers the Delegated Recovery service and what its protocol endpoint URLs are.  This step may be unnecesssary if the Account Provider already knows the configuration for the chosen Recovery Provider.</t><t>The Account Provider generates a recovery token for the User and Recovery Provider.</t><t>The Account Provider sends the Token to the User Agent with instructions to deliver it to the Recovery Provider URL indicated in the configuration.</t><t>Upon receiving the Token, the Recovery Provider authenticates the user if they are not logged in.</t><t>The Recovery Provider makes a GET request to the Account Provider to discover its public keys and protocol URLs.</t><t>The Recovery Provider validates the signature on the token and saves it.</t><t>The Recovery Provider optionally notifies the Account Provider of the status of the operation.</t><t>The Recovery Provider redirects the user agent back to the callback URL indicated by the configuration with a status code.</t></list></t>
        </section>
        <!--Establishing a Delegated Recovery Capability -->
        <section title="Exercising a Delegated Recovery Capability" toc="default">
          <figure title="Figure 2: Exercising a Recovery Capability" suppress-title="false" align="left" alt="" width="" height="">
            <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">

   +--------+           +------+          +----+---+
   |Account |           | User |          |Recovery|
   |Provider|           |      |          |Provider|
   |        |           |      |          |        |
   +-+------+           +--+---+          +----+---+
     |    (optional)       |                   |
     | 1. Initiate Recovery|                   |
     |                     |                   |
     |&lt;--------------------+                   |
     |                     |                   |
     |                     | (optional)        |
     |                     | 2. Retrieve       |
     |                     | Configuration     |
     +----------------------------------------&gt;|
     |&lt;----------------------------------------+
     |                     |                   |
     |    (optional)       |                   |
     | 3. Offer User link  | 1. Initiate       |
     | to Recovery Provider|    Recovery       |
     | with origin hint    |                   |
     +--------------------&gt;+------------------&gt;|
     |                     |                   |
     |                     | 4. (if needed)    |
     |                     | Authenticate User |
     |                     |&lt;------------------+
     |                     +------------------&gt;|
     |                     |                   |
     |                     | 5. Retrieve       |
     |                     | Configuration     |
     |&lt;----------------------------------------+
     +----------------------------------------&gt;|
     |                     |                   |
     |                     | 6. Retrieve and   +---+
     | 7. Send User        | Counter-Sign      |   |
     | Agent to Account    | Recovery Token    |&lt;--+
     | Provider with       |                   |
     | Counter-Signed      |                   |
     | Recovery Token      |                   |
     |&lt;--------------------+&lt;------------------+
     |                     |                   |
     |                     | 8. Retrieve       |
     |                     | Configuration     |
     +----------------------------------------&gt;|
     |&lt;----------------------------------------+
     |                     |                   |
+----+ 9. Validate         |                   |
|    | Recovery Token      |                   |
+---&gt;|                     |                   |
     |                     |                   |
     |                     |                   |
     | 10. Restore Control |                   |
     | of Account          |                   |
     |--------------------&gt;|                   |
     |                     |                   |
     V                     V                   V


</artwork>
          </figure>
          <t>The abstract flow depicting the exercising of a Delegated Recovery capability in Figure 2 describes the interaction between the the roles and includes the following steps: <list style="numbers"><t>The user initiates a recovery, either at the Account Provider, or with the Recovery Provider.</t><t>(optional) the Account Provider GETs the current configuration for the Recovery Provider to be used.</t><t>(optional) The Account Provider offers or redirects the user to the Recovery Provider's endpoint, with a hint of the origin of the account the User wants to recover.</t><t>The Recovery Provider authenticates the user appropriately for conducting a recovery transaction.</t><t>The Recovery Provider makes a GET request to discover the current URL for exercising recovery at the Account Provider.</t><t>The Recovery Provider counter-signs the token and additional fields with its published key.</t><t>The Recovery Provider sends the user agent to the Account Provider's recovery URL with the counter-signed token.</t><t>The Account Provider receives a token, and retrieves the Recovery Provider's current configuration to discover its keys.</t><t>The Account Provider validates the counter-signature, additional fields, its originally issued token, and takes any other necessary steps to complete risk-appropriate re-authentication of the user.</t><t>The Account Provider restores control of the account to the user and allows a new primary authentication method or credential to be established.</t></list></t>
        </section>
        <!--Exercising a Delegated Recovery Capability" -->
      </section>
      <!--Protocol Flow -->
      <section title="TLS Version" toc="default">
        <t>Whenever Transport Layer Security (TLS) is used by this specification, the appropriate version (or versions) of TLS will vary over time, based on the widespread deployment and known security vulnerabilities. At the time of this writing, TLS version 1.2 <xref target="RFC5246" pageno="false" format="default"/>is the most recent and widely deployed version.</t>
        <t>Implementations may also support additional transport-layer security mechanisms that meet their security requirements.</t>
      </section>
      <!--TLS Version -->
      <section title="HTTP Redirections" toc="default">
        <t>This specification makes extensive use of HTTP redirections, in which the client or the authorization server directs the resource owner's user-agent to another destination. While the examples in this specification show the use of the HTTP 302 status code, any other method available via the user-agent to accomplish this redirection is allowed and is considered to be an implementation detail.</t>
        <t>When retrieving configuration servers SHOULD NOT follow redirects to reduce the risk of Server Side Request Forgery.</t>
      </section>
      <!--HTTP Redirections -->
      <section title="Application User Agents" toc="default">
        <t>This specification is written primarily for a general purpose web browser as user agent but this is not the only possible implementation choice. On some platforms, some of either or both of the Account Provider and Recovery Provider functionality may be provided as part of a dedicated, platform-native application, AKA an "app".  Generally, as the protocol aims to coordinate between authenticated sessions at multiple service providers, the platform standard web browser is the most standardized and convenient mechanism available and should be preferred.</t>
      </section>
      <!--Application User Agents -->
    </section>
    <!--Introduction -->
    <section title="Fetching Configuration" toc="default">
      <t>Fetching Configuration is the process of determining the protocol endpoints and public keys used by Account Providers and Recovery Providers.</t>
      <t>Service providers may indicate that configuration responses are cacheable and may cache responses but cache lifetimes should be kept reasonably short to enable timely responses to events such as key compromise.</t>
      <t>Fetching configuration begins by normalizing the service provider to be used into an RFC6454<xref target="RFC6454" pageno="false" format="default"/> ASCII serialization of an Origin with an <spanx style="verb" xml:space="preserve">https</spanx>  scheme.</t>
      <t>Retrieval of the configuration is done using an HTTP <spanx style="verb" xml:space="preserve">GET</spanx> request to the provider's configuration endpoint at the following absolute path relative to the https:// Origin.  <vspace blankLines="0"/> <spanx style="verb" xml:space="preserve">/.well-known/delegated-account-recovery/configuration</spanx> <vspace blankLines="0"/></t>
      <t>The configuration resource path on the http:// scheme MUST NOT redirect to the https:// protocol, as this may mask configuration mistakes by consumers. Servers MUST return an empty response body and an HTTP status code in the 400 range (401 is recommended) if <spanx style="verb" xml:space="preserve">/.well-known/delegated-account-recovery/configuration</spanx> is accessed with the http:// scheme</t>
      <t>When fetching configuration, service providers MUST NOT follow redirects that do not use an https:// scheme.  Service providers generally should avoid utilizing redirects when returning configuration responses.  As it is not mandatory that the issuer field or endpoints in a configuration agree with the origin of the configuration URL, directly returning the canonical data rather than a redirect reduces latency in the protocol.</t>
      <t>A Recovery Provider MUST return the following information in a JSON dictionary comprising the entire response body:</t>
      <texttable style="all" title="" suppress-title="false" align="center">
        <ttcol align="left">name</ttcol>
        <ttcol align="left">value</ttcol>
        <c>issuer</c>
        <c>the RFC6454 ASCII Serialization of the Origin to which this configuration statement applies. MUST have an https: scheme component.</c>
        <c>countersign-pubkeys-secp256r1</c>
        <c>An array of ECDSA public keys on the secp256r1 curve, encoded uncompressed with the named curve OID as per X9.62. The Recovery Provider should not publish more than two keys; enabling key rotation with a small overlap period is the primary purpose of allowing more than one key to be published.</c>
        <c>token-max-size</c>
        <c>The maximum length, in bytes, of a recovery token that the Recovery Provider will accept.</c>
        <c>save-token</c>
        <c>URL of the save token API endpoint defined in section 3</c>
        <c>save-token-async-api-iframe</c>
        <c>URL of the save async token API resource defined in section 3</c>
        <c>recover-account</c>
        <c>URL of the account recovery API endpoint defined in section 3</c>
        <c>privacy-policy</c>
        <c>The URL of a data privacy policy that describes how the issuer handles user data related to account recovery.</c>
        <c>icon-152px</c>
        <c>The URL of a 152x152 pixel PNG file representing the issuer</c>
      </texttable>
      <t>* NOTE: A Recovery Provider may also impose per-account limitations on the total storage or number of recovery tokens it allows. The token-max-size property only sets an upper bound on the length of a single token, and it may still reject tokens below this bound for reasons not discoverable in public configuration.</t>
      <t>An Account Provider MUST return the following information in a JSON dictionary comprising the entire response body:</t>
      <texttable style="all" title="" suppress-title="false" align="center">
        <ttcol align="left">name</ttcol>
        <ttcol align="left">value</ttcol>
        <c>issuer</c>
        <c>The RFC6454 ASCII Serialization of the Origin to which this configuration statement applies. MUST have an https: scheme component.</c>
        <c>tokensign-pubkeys-secp256r1</c>
        <c>An array of ECDSA public keys on the secp256r1 curve, encoded uncompressed with the named curve OID as per X9.62. An Account Provider should not publish more than two keys; enabling key rotation with a small overlap period is the primary purpose of allowing more than one key to be published.</c>
        <c>save-token-return</c>
        <c>URL of the save token return URL defined in section 3</c>
        <c>recover-account-return</c>
        <c>URL of the account recovery callback API endpoint defined in section 3</c>
        <c>privacy-policy</c>
        <c>The URL of a data privacy policy that describes how the issuer handles user data related to account recovery.</c>
        <c>icon-152px</c>
        <c>The URL of a 152x152 pixel PNG file representing the issuer</c>
      </texttable>
      <t>An origin that acts as both an Account and a Recovery provider MUST return a single JSON dictionary as the entire response body containing all required keys.</t>
      <t>URLs <xref target="RFC3986" pageno="false" format="default"/>MUST have a scheme component that is <spanx style="verb" xml:space="preserve">https</spanx>, a host component, and optionally, port and path components, and no query or fragment components. Note that no relationship can be assumed between the host component of the <spanx style="verb" xml:space="preserve">issuer</spanx> input and those of of the URLs in the configuration. (e.g. "https://www.messenger.com" might have account recovery endpoints at "https://www.facebook.com")</t>
    </section>
    <!--Recovery Configuration Discovery -->
    <section title="Protocol Endpoints" toc="default">
      <t>Each phase (establishing, and exercising, an account recovery capability) utilizes three protocol endpoints. (HTTP resources)</t>
      <t>All protocol endpoints MUST use the https:// scheme, and the protocol endpoint paths at the http:// scheme MUST NOT redirect to the https:// protocol, as this may mask configuration mistakes by clients.  A GET or POST to protocol endpoint paths using the http:// scheme MUST yield an empty response body and an HTTP status code 401.</t>
      <t>When establishing a recovery capability, the following endpoints are used: <list style="symbols"><t><spanx style="verb" xml:space="preserve">Save Token</spanx> at the Recovery Provider is the endpoint to which the Account Provider will instruct the user agent to deliver the Recovery Token.</t><t><spanx style="verb" xml:space="preserve">Save Token Async IFrame API</spanx> is a URL from which an HTML resource supporting an async postMessage API for saving tokens can be loaded.  </t><t><spanx style="verb" xml:space="preserve">Save Token Return</spanx> is the endpoint at the Account Provider where the Recovery Provider redirects the user agent after processing an invocation of the <spanx style="verb" xml:space="preserve">Save Token</spanx> endpoint.</t></list></t>
      <t>When exercising a recovery capability, the following endpoints are used: <list style="symbols"><t><spanx style="verb" xml:space="preserve">Recover Account</spanx> at the Recovery Provider is the endpoint at which the User will initiate an account recovery action at an Account Provider. The User may be directed to this resource by the Recovery Provider, or the Account Provider may utilize published configuration to direct the User to this endpoint.</t><t><spanx style="verb" xml:space="preserve">Recover Account Return</spanx> is the endpoint at the Account Provider where the Recovery Provider redirects the user agent with a counter-signed recovery token to complete the recovery of their account</t></list></t>
      <t>Additionally, an Account Provider may optionally provide a "Token Status" endpoint at a well-known location to allow the Recovery Provider to provide direct status updates for tokens, such as the success or failure of saving a token, token deletion, or repudiation of the exercise of a recovery capability.</t>
      <section title="Save Token Endpoint" toc="default">
        <t><spanx style="verb" xml:space="preserve">save-token</spanx> is used to interact with the Recovery Provider and save a recovery token for later use.  The Recovery Provider MUST first authenticate the User. The way in which the Recovery Provider authenticates the User is beyond the scope of this specification.</t>
        <t>Save Token endpoints which expect to receive invocations by web user agents MUST support the HTTP "POST" method and SHOULD reject the HTTP "GET" method.</t>
        <t>If navigating from an Account Provider implemented as a native app to a general purpose web browser and POST is not available, the Account Provider SHOULD first navigate the user agent to a resource under its control and use that resource to perform the POST.</t>
        <t>The POST body MUST be <spanx style="verb" xml:space="preserve">application/x-www-form-urlencoded</spanx> formatted. It MUST contain a parameter <spanx style="verb" xml:space="preserve">token</spanx> containing the recovery token.</t>
        <t>The POST body MAY contain the additional parameter 'login_hint'.  This value may be set to indicate the Account Provider's notion of the primary contact point for the user. A Recovery Provider might match this against the currently logged in user to determine what UI treatments, if any, to apply to confirm saving of the recovery token.</t>
        <t>The POST body MAY contain the additional parameter 'login_hint_sha256'.  This value may be set to indicate the Account Provider's notion of the primary contact point for the user.  A Recovery Provider might match this against the currently logged in user to determine what UI treatments, if any, to apply to confirm saving of the recovery token.  The value should contain the base64 encoded concatenation of a 256 bit random salt value with the binary output of the SHA-256 hashing algorithm applied to the concatenation of the salt and an octet string representing the ASCII serialization of the primary contact point hint for the user at the Account Provider.  Use of 'login_hint_sha256', when compared to 'login_hint', allows matching without disclosure, but introduces the possibility that legitimate matches will not be discovered due to differences in how contact point hints are represented or canonicalized before hashing.</t>
        <t>The POST body MAY contain an additional parameter 'nickname_hint' to suggest a nickname for the account to which the token relates.</t>
        <t>The POST body MAY contain an additional parameter 'confirmation'. If set to the value 'required', this indicates to the Recovery Provider that it SHOULD show some form of interstitial explicitly informing the user that a token will be saved, with the option to decline.</t>
        <t>The POST body type MAY contain an additional parameter, 'obsoletes'.  The value of the 'obsoletes' is a token id which the current token is intended to replace.  If the user at the Recovery Provider has a saved token with an id and issuer matching this property, it should be deleted or marked as invalid if the new token is successfully saved.</t>
        <t>The POST body MAY contain an additional parameter 'state', the value of which will be passed to the 'save-token-return' endpoint, unmodified.</t>
        <section title="Processing Instructions" toc="default">
          <t>When a user wishes to save a recovery token, the Account Provider takes the following processing steps: <list style="numbers"><t>Authenticate the User. The exact nature of how the Account Provider authenticates the User is beyond the scope of this specification.</t><t>Obtain and normalize an origin with an <spanx style="verb" xml:space="preserve">https</spanx> scheme from the user indicating the domain of their chosen Recovery Provider. Users might indicate this choice by picking among pre-configured options, entering a domain name, or it might be inferred from the domain portion of an email address.</t><t>Retrieve the Recovery Provider configuration as described in Section 2.</t><t>If necessary configuration cannot be obtained, abort these steps.</t><t>Prepare a recovery token as described in Section 4. Use the 'issuer' field of the retrieved configuration as the value of the 'audience' field in the token.</t><t>The Account Provider may save the token_id and audience fields from the token associated with the User's account, to assist the user in completing a recovery process at a future time.</t><t>The Account Provider should have some method of mapping an issued recovery token to the original public key it was issued under and any key used to encrypt the opaque data, to be able to complete the protocol when the token is returned. This might be maintained as server-side state, or key ids might be encoded into the token_id field.</t><t>Instruct the user's agent to POST the token to the Save Token endpoint at the Recovery Provider. The Account Provider may choose to do this in a new browsing context. (e.g. a popup)</t></list></t>
          <t>Upon receiving an invocation of the Save Token endpoint the Recovery Provider takes the following processing steps: <list style="numbers"><t>Authenticate the User. The exact nature of how the Recovery Provider authenticates the User is beyond the scope of this specification.</t><t>Parse the token.</t><t>Validate that the version value is 0.</t><t>Validate that the type value is 0.</t><t>Retrieve the Account Provider configuration as described in Section 2 using the issuer field of the token as the subject.  HTTP redirects SHOULD NOT be followed.</t><t>Validate that the value of the issuer field of the configuration matches the value of the issuer field of the recovery token.</t><t>Validate the signature over the token according to processing rules for the algorithm implied by the version.</t><t>Validate that the audience field of the token identifies an origin which the provider considers itself authoritative for.  (Often the audience will be same-origin with the Recovery Provider, but other values may be acceptable, e.g.  "https://mail.example.com" and "https://social.example.com" may be acceptable audiences for "https://recovery.example.com".)</t><t>Validate that the timestamp is fresh within an acceptable clock skew.</t><t>If a token binding is present or required, validate that it is acceptable.</t><t>Save the token for the User. The means by which a Recovery Provider saves the token is beyond the scope of this specification.</t><t>Because recovery tokens do not reveal the account name at the Account Provider, and because a User might have multiple accounts, Recovery Providers may give the User an option to add attach a nickname (e.g. "home", "work") or other means of identifying the account the token is associated with.</t><t>When the user has completed the operation successfully, or if the user aborted or abandoned the operation, or if the operation cannot be completed due to an unrecoverable error, if the token's <spanx style="verb" xml:space="preserve">status_requested</spanx> field is 1, the Recovery Provider MAY invoke the Token Status endpoint <spanx style="verb" xml:space="preserve">token-status</spanx> for the <spanx style="verb" xml:space="preserve">save-success</spanx> or <spanx style="verb" xml:space="preserve">save-failure</spanx> status, as appropriate, following the processing instructions for that operation described below.</t><t>Redirect the User or user agent to the <spanx style="verb" xml:space="preserve">save-token-return</spanx> endpoint defined by the Account Provider configuration, including the GET parameter "status" set to the value "save-success" or "save-failure" to report whether a token was successfully saved, regardless of whether asynchronous status updates for the token were requested.</t><t>If a 'state' parameter was included with the original request, send its value, unmodified, as an additional parameter in the redirect.</t></list></t>
        </section>
        <!--Processing Instructions -->
      </section>
      <!--Save Token Endpoint -->
      <section title="Save Token Return Endpoint" toc="default">
        <t>Save Token Return is used to return the User to the Account Provider after invoking Save Token at the Recovery Provider.</t>
        <t>Save Token Return endpoints MUST support both the HTTP <spanx style="verb" xml:space="preserve">GET</spanx> and <spanx style="verb" xml:space="preserve">POST</spanx> methods.</t>
        <t>Upon receiving an invocation of the Save Token Return endpoint the Recovery Provider may use the "status" parameter to report whether a token was successfully saved, regardless of whether asynchronous status updates for the token were requested.  The 'state' parameter may be used, if needed, to determine the next action to be taken.</t>
      </section>
      <!--Save Token Return Endpoint -->
      <section title="Save Token Async API Endpoint" toc="default">
        <t>In order to facilitate greater control over the user experience for an Account Provider, or to expose advanced features, a Recovery Provider may optionally provide as part of its configuration a save-token-async-api-iframe URL.</t>
        <t>This URL may be used as the src attribute of an &lt;iframe&gt; tag in an HTML document. When loaded, the resource MUST expose an API based on HTML cross-document messaging.  (https://html.spec.whatwg.org/multipage/comms.html#web-messaging)</t>
        <t>The details of how such a resource communicates with services at the Recovery Provider are not normatively specified by this document.</t>
        <t>The normative API exposed is as follows:</t>
        <section title="Asynchronous Message Contract" toc="default">
          <t>The <spanx style="verb" xml:space="preserve">message</spanx> argument to <spanx style="verb" xml:space="preserve">postMessage()</spanx> MUST be a JSON object.</t>
          <t>Messages related to this API MUST always contain the property 'delegated-account-recovery-api-message' with a value indicating the type of the protocol message.</t>
          <t>The following message types are defined by their literal string values: <list style="hanging" hangIndent="4"><t hangText="ready"><vspace blankLines="0"/>Sent by API to parent to indicate it is ready to receive messages.</t><t hangText="save-token"><vspace blankLines="0"/>Sent to API to initiate a token save operation that completes the operation and returns results by navigating the parent frame.</t><t hangText="save-token-no-navigation"><vspace blankLines="0"/>Sent to API to initiate a token save operation. Calls of this type MUST NOT result in the parent frame being navigated.  Results are returned with a 'save-token-result' message.</t><t hangText="save-token-async-only"><vspace blankLines="0"/>Sent to API to initiate a token save operation. Calls of this type MUST NOT result in the parent frame being navigated.  Results are returned with a 'save-token-result' message.</t><t hangText="save-token-result"><vspace blankLines="0"/>Sent by API to parent frame to indicate completion status of a 'save-token-no-navigation' or 'save-token-async-only' message.</t><t hangText="get-binding"><vspace blankLines="0"/>Sent to API to retrieve a token binding.</t><t hangText="binding"><vspace blankLines="0"/>Sent by API to parent in response to a 'get-binding' message to convey a token binding string.</t></list></t>
          <t>For messages that elicit a response, the Account Provider may set an 'id' property on the message. If present, the Recovery Provider MUST include its value as the value of the property 'in-reply-to' in the correlated response.</t>
          <t>The Account Provider SHOULD set the targetOrigin parameter to the origin of the URL obtained from the Recovery Provider configuration, to reduce the risk that messages will be visibile to unintended recpiients.</t>
          <t>On loading, the async API resource MUST post a message to its parent of type 'ready'.</t>
          <section title="save-token message" toc="default">
            <t>This message type MUST have an additional property, 'token', that contains the base64 encoded recovery token to be saved.</t>
            <t>This message type MAY contain the additional property 'login_hint'.  These values may be set to indicate the Account Provider's notion of the primary contact points for the user. A Recovery Provider might match these against the currently logged in user to determine what UI treatments, if any, to apply to confirm saving of the recovery token.</t>
            <t>This message type MAY contain an additional property 'nickname_hint' to suggest a nickname for the account to which the token relates.</t>
            <t>This message type MAY contain an additional property 'state' which will be passed, unmodified, as part of the redirect to the 'save-token-return' endpoint.</t>
            <t>This message type MAY contain an additional property, 'obsoletes'.  The value of the 'obsoletes' property is a token id which the current token is intended to replace.  If the user at the Recovery Provider has a saved token with an id and issuer matching this property, it should be deleted or marked as invalid if the new token is successfully saved.</t>
            <t>If no other keys are set on the message, the behavior of the Recovery Provider iframe will be to process the message and navigate the parent frame based on the results of that processing.</t>
            <t>If the Recovery Provider needs to perform additional interactions with the user to complete saving the token, (such as login, confirmation of the save or collecting a token nickname) it can redirect the parent window to whatever location is necessary to complete the flow interactively at the Recovery Provider.  It SHOULD always attempt to return the user to the Account Provider's save-token-return endpoint at the end of these flows, with the provided 'state' parameter, whether successful or not.</t>
            <t>If the recovery token can be saved without user interaction, the iframe SHOULD navigate the parent frame directly to the Account Provider's save-token-return endpoint with the status parameter set to 'save-success' and any 'state' parameter set.</t>
          </section>
          <!--save-token message -->
          <section title="save-token-no-navigation message" toc="default">
            <t>This message has identical arguments to the 'save-token' message.</t>
            <t>It is processed identically, except it MUST NOT navigate the parent frame.  Instead, results are conveyed by it issuing a postMessage() to its parent window with a message of type 'save-token-result' and a 'result' property.</t>
            <t>This method may be preferred by a caller that wants to guarantee the user isn't navigated away from a critical experience they are interacting with, like an account creation funnel.  The account provider might choose to, e.g. open a popup with a POST directly to the 'save-token' endpoint to complete any interaction with the Recovery Provider if the value of 'result' is not 'save-success'.  </t>
            <t>The value of the 'state' property on the message, if set, is ignored.</t>
          </section>
          <!--save-token-no-navigation message -->
          <section title="save-token-async-only message" toc="default">
            <t>This message has identical arguments to the 'save-token' message.</t>
            <t>It is processed identically, except that instead of navigating the parent frame, it issues a postMessage() to its parent window immediately after the message is accepted, with a message type of 'save-token-result' and a 'result' property.  The only valid value for the 'result' key in response to a 'save-token-async-only' message is 'done'. No indication is provided of the success or failure of the operation.</t>
            <t>How a message is determined to be accepted is an implementation detail at the discretion of the Recovery Provider.  It might reject messages locally (e.g. if it does not support silent acceptance for this Account Provider or the user), it might dispatch them immediately using an API like Beacon, if available, or it may need to make an asynchronous HTTP request and wait for a response. It SHOULD indicate "done" to the caller at the earliest practical moment.</t>
            <t>This protocol message would typically be employed with a token that sets the 'status-requested' flag and by an Account Provider that keeps track of what recovery tokens have been recorded for an account. It might be used to optimistically enroll users in recovery as part of another action, with an offer to complete the flow interactively at a later time made to users not successfully enrolled asynchronously.</t>
            <t>The value of the 'state' property on the message, if set, is ignored.</t>
          </section>
          <!--save-token-async-only message -->
          <section title="save-token-result message" toc="default">
            <t>This message is sent to the parent frame in response to a 'save-token-no-navigation' or 'save-token-async-only' message.</t>
            <t>This message contains a 'result' property. If sent in response to a 'save-token-no-navigation' message, the value of result will be either 'save-token-success' or 'save-token-failure', indicating whether the token was saved without user interaction.  If sent in response to a 'save-token-async-only' message, the value is always 'done', indicating when it is safe to navigate or otherwise destroy the iframe hosting the API.</t>
          </section>
          <!--save-token-result message -->
          <section title="get-binding message" toc="default">
            <t>This message indicates a request for a token binding string from the Recovery Provider.  The reply contains a string that should be treated as opaque by the receiver and placed into the 'binding' field of a recovery token.</t>
            <t>Bindings are optional according to this specification but individual Recovery Providers MAY, at their discretion, require a token contain a valid binding to be saved.</t>
            <t>Bindings SHOULD be considered to be unique and single-use and the string received in response to a call to 'get-binding' SHOULD NOT be associated to more than one token.</t>
            <t>This message has no arguments other than the optional 'id' for reply correlation.</t>
          </section>
          <!--get-binding message -->
          <section title="binding message" toc="default">
            <t>This message replies to a 'get-binding' message.</t>
            <t>The API MUST provide a response to such a message. An empty string is a valid binding string.</t>
            <t>The property 'binding' of this message contains the binding string.</t>
            <t>A recipient of this message SHOULD treat it as unique and single-use, but the API implementation MAY return the same binding string for multiple invocations at the same instance of the iframe resource.</t>
          </section>
          <!--binding message -->
          <section title="Implementation Considerations" toc="default">
            <t>Recovery Providers are not required to process all APIs uniformly. For example, a Recovery Provider might refuse to process 'save-token-async-only' messages from certain issuers, or only attempt to process them if the Account Provider is the canonical owner of the users's primary contact point at the Recovery Provider. (e.g. a Recovery Provider might silently accept a recovery token from https://example.com only if it's own view of the authenticated user had a confirmed email address at example.com)</t>
          </section>
          <!--implementation considerations -->
          <section title="Privacy Considerations" toc="default">
            <t>Implementers should take caution that the binding message does not leak information about a user. It SHOULD NOT provide the same or a correlatable response across different instances of the iframe resource implementing the API, and SHOULD NOT provide bindings that are distinguishable by callers based on user state or properties. (logged in, user identifier, user IP address, etc)</t>
          </section>
        </section>
        <!--Asynchronous Message Contract -->
      </section>
      <!--Save Token Async API Endpoint -->
      <section title="Recover Account Endpoint" toc="default">
        <t>The Recover Account endpoint is used to exercise a saved recovery capability.</t>
        <t>A user may arrive at the Recover Account Endpoint in at least two ways: <list style="symbols"><t>The user deliberately visits the Recovery Provider and requests, through a means outside the scope of this specification, to view all of their saved tokens or those for a particular Account Provider.</t><t>The User visits the Account Provider and is unable to authenticate. As part of an account recovery flow, the Account Provider sends the user to this endpoint at the Recovery Provider.</t></list></t>
        <t>Recover Account endpoints MUST support both the HTTP GET and POST methods.</t>
        <t>A query string or <spanx style="verb" xml:space="preserve">application/x-www-form-urlencoded</spanx> formatted POST body MAY be provided. If a query string is provided, it MAY contain the parameter <spanx style="verb" xml:space="preserve">issuer</spanx> set to the origin of the Account Provider and/or a <spanx style="verb" xml:space="preserve">id</spanx> parameter set to the hex value of a token_id. These parameters can be used by the Recovery Provider to guide the user in selecting the correct token. For example, if used as part of a cryptographic key recovery ceremony, it may be necessary to select a specific token among several the user has saved from a given issuer.</t>
        <t>Upon receiving an invocation of the Recover Account endpoint the Recovery Provider takes the following processing steps: <list style="numbers"><t>Authenticate the user. The exact nature of how the Recovery Provider authenticates the user is beyond the scope of this specification.</t><t>Select a token to exercise, based on some combination of user choice and input parameters.</t><t>Retrieve the configuration for the token issuer as described in Section 2.</t><t>Create a counter-signed token as described in Section 4 and sign the token according to the algorithm's requirement.</t><t>Redirect the user agent to the "recover-account-return" endpoint defined by the Account Provider configuration. The "application/x-www-form-urlencoded" formatted POST body should include the parameter "countersigned-token" set to the countersigned token.</t><t>The Recovery Provider should notify the user, via an out-of-band means, that a recovery token has been exercised, for which domain and nickname, if applicable.</t><t>If any of these steps fails, abort the algorithm.</t></list></t>
      </section>
      <!--Recover Account Endpoint -->
      <section title="Recover Account Return Endpoint" toc="default">
        <t>The Recover Account Return endpoint is used to return the User to the Account Provider after invoking Recover Account at the Recovery Provider.</t>
        <t>Recover Account Return endpoints MUST support the HTTP POST and SHOULD reject the HTTP GET method.</t>
        <t>If navigating from a Recovery Provider implemented as a native app to a general purpose web browser and POST is not available, the Recovery Provider SHOULD first navigate the user agent to a resource under its control and use that resource to perform the POST.</t>
        <t>The POST body MUST be <spanx style="verb" xml:space="preserve">application/x-www-form-urlencoded</spanx> formatted. It must contain the query parameter <spanx style="verb" xml:space="preserve">countersigned-token</spanx> containing the countersigned recovery token.</t>
        <t>Upon receiving an invocation of the Recover Account Return endpoint the Account Provider takes the following processing steps: <list style="numbers"><t>Parse the countersigned-token.</t><t>Validate that the version field is 0.</t><t>Validate that the type field is 1.</t><t>De-serialize the original recovery token from the data field.</t><t>Validate the signature on the original recovery token.</t><t>Validate the issuer field is present in the countersigned-token, and that it matches the audience field in the original token.</t><t>Validate that the timestamp is fresh within an acceptable closk skew.</t><t>Validate the token binding for the countersigned token, if present. (the token binding for the inner token is not relevant)</t><t>Optionally, validate that a token with this id has not been recently used to recover this account, as an additional protection against replay attacks.</t><t>Retrieve the current Recovery Provider configuration as described in Section 2.  HTTP redirects SHOULD NOT be followed when retrieving the configuration.</t><t>Validate that the issuer field of the retrieved configuration matches that of the counter-signed token.</t><t>Validate that the counter-signed token signature validates with a current element of the <spanx style="verb" xml:space="preserve">countersign-pubkeys-secp256r1</spanx> array.</t><t>Decrypt the data field from the original recovery token and parse its information, if present.</t><t>Apply any additional processing which provider-specific data in the opaque data portion may indicate is necessary.</t><t>If all steps have completed successfully, the recovery token may be considered to have been successfully applied. At this point the Account Provider may restore control of the account to the user.  The details of that process are beyond the scope of this specification. An Account Provider may consider the completion of this algorithm as only a single factor in a risk-based assessment relating to account recovery and may require additional steps to complete the process. Such decisions and steps are beyond the scope of this specification.</t><t>The Account Provider should make a permanent record of the recovery noting the Recovery Provider and time of recovery, to remediate fraudulent recoveries in the event that a compromise is subsequently determined to have occurred at the Recovery Provider.</t><t>The Account Provider should notify the User via an out-of-band means that an account recovery has occurred.</t></list></t>
      </section>
      <!--Recover Account Return Endpoint -->
      <section title="Token Status Endpoint" toc="default">
        <t>The Token Status endpoint is used by the Recovery Provider to notify the Account Provider about the current status of a particular token in the following cases: <list style="numbers"><t>When a new token is first saved, or fails to save, at the Recovery Provider.</t><t>When a token is deleted at the Recovery Provider, or when the associated account at the Recovery Provider is deleted or deactivated.</t><t>When a token save or recovery action is repudiated by the holder of a token at the Recovery Provider.</t></list></t>
        <t>The Token Status Callback MUST be hosted at the following well known location, relative to the server root of the https origin of the Account Provider in the token.</t>
        <t>/.well-known/delegated-account-recovery/token-status</t>
        <t>Token Callback endpoints MUST support both the HTTP <spanx style="verb" xml:space="preserve">POST</spanx> and <spanx style="verb" xml:space="preserve">GET</spanx> methods.</t>
        <section title="Processing Instructions" toc="default">
          <t>Support for Token Status Callbacks is optional for both the Account Provider and Recovery Provider.</t>
          <t>If an Account Provider wishes to receive Token Status Callbacks it MUST set the <spanx style="verb" xml:space="preserve">status_requested</spanx> field of the recovery token to 1.</t>
          <t>If an Account Provider does not intend to take action based on Token Status Callbacks or wishes to provide additional unlinkability and privacy guarantees for a token it SHOULD set the <spanx style="verb" xml:space="preserve">status_requested</spanx> field to 0.</t>
          <t>The following token lifecycle events can be reported to an Account Provider by a Recovery Provider: <list style="symbols"><t><spanx style="verb" xml:space="preserve">save-success</spanx> reports that a token has been successfully saved with the Recovery Provider.</t><t><spanx style="verb" xml:space="preserve">save-failure</spanx> reports that a token was sent to the Recovery Provider but was not saved.</t><t><spanx style="verb" xml:space="preserve">deleted</spanx> reports that the user has deleted the token at the Recovery Provider. The Account Provider may want to prompt the user to establish a new account recovery capability if the deleted token was the only one associated with the account.</t><t><spanx style="verb" xml:space="preserve">token-repudiated</spanx> reports that a user has informed the Recovery Provider that a token was associated with their account without their consent.</t><t><spanx style="verb" xml:space="preserve">recovery-repudiated</spanx> reports that a user has informed the Recovery Provider that a recovery action was initiated with a token without their consent.</t></list></t>
          <t>When sending a lifecycle event, the Recovery Provider invokes the well-known endpoint with a <spanx style="verb" xml:space="preserve">application/x-www-form-urlencoded</spanx> formatted <spanx style="verb" xml:space="preserve">POST</spanx> body including the parameter <spanx style="verb" xml:space="preserve">id</spanx> set to the hex-encoded value of the <spanx style="verb" xml:space="preserve">token_id</spanx> field of the recovery token, and the parameter <spanx style="verb" xml:space="preserve">status</spanx> set to the literal ASCII string of the status event from the above enumeration. (e.g.  <spanx style="verb" xml:space="preserve">save-success</spanx> or <spanx style="verb" xml:space="preserve">deleted</spanx>)</t>
          <t>If the event being reported is <spanx style="verb" xml:space="preserve">recovery-repudiated</spanx> the Recovery Provider SHOULD also include a parameter, <spanx style="verb" xml:space="preserve">countersigned_id</spanx>, set to the hex-encoded value of the <spanx style="verb" xml:space="preserve">token_id</spanx> field for the countersigned recovery token associated with the recovery action being repudiated.</t>
        </section>
        <!--Processing Instructions -->
        <section title="Security Considerations" toc="default">
          <t>Because the Token Status Callback is a direct, server-to-server call, hosting this endpoint only at a well-known location reduces the risk of Server-Side Request Forgery.</t>
          <t>Although the recommended entropy in the token id should make brute-force of fraudulent events difficult, Account Providers might choose to only request status callbacks from known Recovery Providers and only accept requests from known IP ranges or require additional authentication mechanisms beyond the scope of this protocol to mitigate risks of forgery and denial-of-service with such requests.</t>
        </section>
      </section>
      <!--Token Status Endpoint -->
    </section>
    <!--Protocol Endpoints -->
    <section title="Token Generation" toc="default">
      <section title="Recovery Token" toc="default">
        <t>A Recovery Token is a credential representing the ability to recover control of an account. It is defined as:</t>
        <t>token = base64(token_internals || token_signature)</t>
        <section title="Internal Structure" toc="default">
          <t>The internal contents of a token are as follows:</t>
          <figure title="" suppress-title="false" align="left" alt="" width="" height="">
            <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">

token_internals = struct {
        uint8    version
        uint8    type
        byte[16] token_id
        uint8    options
        uint16   issuer_length
        string   issuer[issuer_length]
        uint16   audience_length
        string   audience[audience_length]
        unit16   issued_time_length
        string   issued_time[issued_time_length]
        uint16   data_length
        opaque   data[data_length]
        uint16   binding_length
        opaque   binding[binding_length]
 }


</artwork>
          </figure>
          <t><list style="hanging" hangIndent="4"><t hangText="version"><vspace blankLines="0"/>Version identifier. For this version of the protocol, the value MUST be 0.</t><t hangText="type"><vspace blankLines="0"/>Message type. For the recovery token, the type is 0.</t><t hangText="token_id"><vspace blankLines="0"/>Token identifier. The identifier SHOULD contain at least 96 bits of entropy. Because tokens may persist for a very long time, issuers may wish to use a portion of the token_id field to encode an identifier for the keys used originally to sign the token and encrypt its data, to assist in revalidation in the event that rotations of those keys have occurred since the token was originally issued.</t><t hangText="options"><vspace blankLines="0"/>MUST be 0 if the Account Provider does not want status callbacks or 1 to request the Recovery Provider to make status callbacks, if supported.</t><t hangText="issuer_length"><vspace blankLines="0"/>Length of the issuer field.</t><t hangText="issuer"><vspace blankLines="0"/>The ASCII serialization of the Account Provider's Origin <xref target="RFC6454" pageno="false" format="default"/></t><t hangText="audience_length"><vspace blankLines="0"/>Length of the audience field.</t><t hangText="audience"><vspace blankLines="0"/>The contents of the issuer field in the Recovery Provider's published configuration.</t><t hangText="issued_time_length"><vspace blankLines="0"/>Length of the issued_time field.</t><t hangText="issued_time"><vspace blankLines="0"/>The ASCII serialization of the time the token was issued, represented as an ISO 8601 <xref target="ISO.8601.1988" pageno="false" format="default"/>Internet Date/Time using the 'date-time' ABNF defined by RFC3339.  <xref target="RFC3339" pageno="false" format="default"/></t><t hangText="data_length"><vspace blankLines="0"/>Length of the data.</t><t hangText="data"><vspace blankLines="0"/>Opaque data.</t><t hangText="binding_length"><vspace blankLines="0"/>Length of the binding.</t><t hangText="binding"><vspace blankLines="0"/>Opaque token binding identifier obtained from the get-token endpoint.</t></list> </t>
        </section>
        <!--Internal Structure -->
        <section title="Opaque Data" toc="default">
          <t>The opaque data contains information that the Account Provider needs to validate and restore control of an account, but which should not be shared with the Recovery Provider. It MUST be encrypted to prevent disclosure of its internal structure.</t>
          <t>Because it is encrypted and opaque, it may contain whatever information in whatever format the Account Provider feels is necessary and appropriate, but any information beyond that specified for inclusion in the outer token MUST be placed in the encrypted portion and protected from disclosure to the Recovery Provider.</t>
          <t>Recovery Providers MAY reject a token that is too large.</t>
          <t>The choice of algorithm and key management is left to the discretion of the Account Provider.</t>
          <t>A recovery token may still be usable even if an attacker obtains the key used to encrypt the opaque data, (though user privacy may be compromised) but if the Account Provider loses this key (and the ability to decrypt the token data) the account recovery capability will be lost.</t>
        </section>
        <!--Opaque Data -->
        <section title="Signature" toc="default">
          <t>token_signature is a signature over the token_internals octet string as defined according to the version field, with the private key corresponding to the public key for the Recovery Provider currently published as part of its configuration.</t>
          <t>For this version (0) of the protocol, this is ECDSA over the SHA256 hash of the token_internals octet string.  The signature is encoded as DER-encoded ASN.1 structure (a SEQUENCE of two INTEGERs, for r and s, in that order).</t>
        </section>
        <!--Signature -->
      </section>
      <!--Recovery Token -->
      <section title="Counter-Signed Recovery Token" toc="default">
        <t>A Counter-Signed Recovery Token is a credential representing the Recovery Provider's re-authentication of the account holder who originally saved the Recovery Token it contains. It is defined as:</t>
        <t>token = base64(countersigned_token_internals || countersigned_token_signature)</t>
        <section title="Internal Structure" toc="default">
          <t>The internal contents of a countersigned token are as follows:</t>
          <figure title="" suppress-title="false" align="left" alt="" width="" height="">
            <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">

countersigned_token_internals = struct {
        uint8    version
        uint8    type
        byte[16] token_id
        uint8    options
        uint16   issuer_length
        string   issuer[issuer_length]
        uint16   audience_length
        string   audience[audience_length]
        uint16   issued_time_length
        string   issued_time[issued_time_length]
        uint16   data_length
        opaque   data[data_length]
        uint16   binding_length
        opaque   binding[binding_length]
 }


</artwork>
          </figure>
          <t><list style="hanging" hangIndent="4"><t hangText="version"><vspace blankLines="0"/>Version identifier. For this version of the protocol, the value MUST be 0.</t><t hangText="type"><vspace blankLines="0"/>Message type. For the countersigned recovery token, the type is 01.</t><t hangText="token_id"><vspace blankLines="0"/>Token identifier. This SHOULD contain at least 96 bits of entropy.</t><t hangText="options"><vspace blankLines="0"/>Reserved. MUST be 0</t><t hangText="issuer_length"><vspace blankLines="0"/>Length of the issuer field.</t><t hangText="issuer"><vspace blankLines="0"/>The ASCII serialization of the Account Provider's Origin <xref target="RFC6454" pageno="false" format="default"/></t><t hangText="audience_length"><vspace blankLines="0"/>Length of the audience field.</t><t hangText="audience"><vspace blankLines="0"/>This SHOULD repeat the contents of the inner recovery token's issuer field.</t><t hangText="issued_time_length"><vspace blankLines="0"/>Length of the issued_time field.</t><t hangText="issued_time"><vspace blankLines="0"/>The ASCII serialization of the time this token was issued, represented as an ISO 8601 <xref target="ISO.8601.1988" pageno="false" format="default"/>Internet Date/Time using the 'date-time' ABNF defined by RFC3339.  <xref target="RFC3339" pageno="false" format="default"/></t><t hangText="data_length"><vspace blankLines="0"/>Length of the data.</t><t hangText="data"><vspace blankLines="0"/>The octet string of the original (token_internals || token_signature) as received by the Recovery Provider. (after base64 decoding)</t><t hangText="binding_length"><vspace blankLines="0"/>Length of the token binding id.</t><t hangText="binding"><vspace blankLines="0"/>Opaque token binding id obtained from the get-binding endpoint.</t></list> </t>
        </section>
        <!--Internal Structure -->
        <section title="Counter-Signed Recovery Token Signature" toc="default">
          <t>countersigned_token_signature is a signature over the countersigned_token_internals octet string as defined according to the algorithm field, with the private key corresponding to the public key for the Recovery Provider currently published as part of its configuration.</t>
          <t>For this version of the protocol (0), the algorithm is ECDSA over the SHA256 hash of the countersigned_token_internals octet string. The signature is encoded as DER-encoded ASN.1 structure (a SEQUENCE of two INTEGERs, for r and s, in that order)</t>
        </section>
        <!--Counter-Signed Recovery Token Signature -->
      </section>
      <!--Counter-Signed Recovery Token -->
    </section>
    <!--Token Generation -->
    <section title="Use in Key Recovery" toc="default">
      <t>This protocol, in addition to allowing recovery of accounts in a delegated fashion, may be used to recover other capabilities, like a recovery key for encrypted email or files. For example, the provider of a an encryption service might use a threshold cryptosystem to break a key into several parts, and ask the user to store the pieces (encoded in the opaque data field) as account recovery tokens at several providers. If the user loses their own copy of the key, they can still recover it, but the backup is not subject to server-side compromise by any single entity.</t>
    </section>
    <!--Use in Key Escrow and Recovery -->
    <section title="Security Considerations" toc="default">
      <section title="Deterministic Use of ECDSA" toc="default">
        <t>As even slight biases in the selection of the random value k used by ECDSA can lead to a key compromise.  As such, implementers SHOULD follow the method described in <xref target="RFC5246" pageno="false" format="default"/> for generating deterministic values of k.</t>
      </section>
      <section title="User Notification" toc="default">
        <t>Users should be notified, by both the Recovery Provider and Account Provider, whenever a recovery capability is exercised, in order to provide an opportunity to react if they did not initiate the action.  Out-of-band means (email, instant message, SMS, etc.) should be preferred to reduce the opportunity for an attacker in control of a user's account to remove such signals.</t>
      </section>
      <section title="Additional Verification" toc="default">
        <section title="At the Recovery Provider" toc="default">
          <t>An explicit goal of this specification is that account recovery operations can be explicitly recognized as high-risk operations and subject to additional authentication controls by a Recovery Provider. Recovery Providers should treat the exercising of a recovery capability as a high risk action and require a high degree of confidence in the user's authentication to perform it. The nature of this is application-specific at each Recovery Provider.</t>
          <section title="Session Fixation" toc="default">
            <t>To achieve a convenient and privacy-preserving user experience many Recovery Providers will rely on the ambient authority of the user's browser (e.g. cookies) to associate a recovery token to their account. If an attacker can execute a session fixation attack on a user, in which the user is unknowingly logged out of their account and logged in to a different account under the control of an attacker (e.g. through a logout/login CSRF attack), and then convince the user to save an account recovery token, the attacker may be able to use that to take control of the account for which the token grants a recovery capability.</t>
            <t>To mitigate this risk, Recovery Providers should take precautions to prevent Cross-Site Request Forgery against login/logout endpoints. Recovery Providers may also wish to track, for example through persistent cookies, which user agents have been used with multiple accounts, and require additional confirmation that the user is aware of the current logged in user state before saving a recovery token.</t>
          </section>
        </section>
        <!--At the Recovery Provider -->
        <section title="At the Account Provider" toc="default">
          <t>This specification does not mandate that a counter-signed recovery token be the exclusive means by which an Account Provider allows restoring control or resetting the credentials of an account. They may treat it as only one authentication signal among many possible or necessary ones. Resetting a high-value account might require, e.g. multiple instances of this protocol to be completed with independent Recovery Providers, or make use of additional authentication factors exclusively at the Account Provider.</t>
          <t>Whether to accept or reject a presented counter-signed recovery token is always at the discretion of the Account Provider. Use of this protocol does not imply any contract or obligation to honor any previously saved recovery capability.</t>
          <t>The opaque data field can be also be used to encapsulate additional information to use in strengthening the process. For example, a traditional account recovery "secret question" and its answer might be encoded into this data. This implementation reduces many of the risks of such questions, as they cannot be seen or brute-force guessed by an attacker that has not already compromised the user's account at the Recovery Provider, and the content of such question / answer sets cannot leak through a data breach at either the Recovery or Account Provider individually.</t>
          <t>If a user recovers their account following a period of compromise, the Account Provider should take precautions to invalidate any new recovery tokens that may have been issued during the compromise period.</t>
        </section>
        <!--At the Account Provider -->
      </section>
      <!--Additional Verification -->
      <section title="Cross-Site Request Forgery" toc="default">
        <t>Many web application endpoints require an unforgeable token be sent as part of any HTTP POST to prevent Cross-Site Request Forgery (CSRF) attacks from abusing the ambient authority represented by cookies or other implicit credentials sent by a web user agent.</t>
        <t>Because the architecture of Delegated Account Recovery relies on deliberate cross-origin POSTs, normal protections of this sort cannot be applied to the endpoints specified by this specification.</t>
        <t>To prevent abuse, both Account and Recovery Providers should require explicit user confirmation of actions in pages that contain anti-automation measures, e.g. by setting an X-Frame-Options header <xref target="RFC7034" pageno="false" format="default"/> or Content-Security-Policy "frame-ancestors" directive to prevent clickjacking attacks.</t>
        <t>Initiating sending a recovery token to a recovery provider should be protected against Cross-Site Request Forgery and clickjacking, to prevent users being tricked into sending tokens to fraudulent providers. Account Providers may want to take special measures to require unforgeable user consent or block entirely the delegation of tokens to low-reputation Recovery Providers.</t>
      </section>
      <!--Cross-Site Request Forgery -->
      <section title="Breach Detection" toc="default">
        <t>Participants should monitor rates at which recovery capabilities are exercised and rates at which users report unauthorized exercising of recovery capabilities. A high rate of unauthorized recovery actions initiated at a given Recovery Provider may indicate a compromised or malicious provider. Both Recovery and Account Providers should publish contact information for use in incident reporting and response. Verification of token bindings and issued_time freshness should also be performed to prevent disclosed tokens from being re-associated to new accounts at a Recovery Provider.</t>
      </section>
      <section title="Clock Skew" toc="default">
        <t>This protocol relies on comparison of timestamps from different network servers as a defense-in-depth measure to prevent re-use of leaked tokens, in particular re-association of a leaked token with a different account at the same audience server. Although client clock skews are a frequent issue for protocols with such dependencies, this protocol only depends on reasonable clock synchronization between servers, never the user-managed client clock. Participating servers in this protocol should endeavor to issue tokens as close in time to when they will be transmitted as possible and should take steps to reduce their own clock skew, for example, by periodic synchronization with standardized Internet time sources. The specifics of such mechanisms are beyond the scope of this document.</t>
      </section>
      <section title="Key Loss and Compromise" toc="default">
        <t>This protocol involves three keys: the public/private key pairs of the Account and Recovery Providers, and whatever key the Account Provider uses to encrypt the opaque data. Additionally, the recovery tokens themselves convey some security capability. The protocol can offer some resilience to loss or compromise of these keys and artifacts.</t>
        <t>If the Recovery Provider's key is compromised, it should publicize the window in which it was compromised, and should notify Account Providers with whom recovery capabilities were exercised during the window of compromise. Mechanisms to communicate this are outside the scope of this protocol. If notified by a Recovery Provider of a key compromise, Account Providers should identify recovery capabilities exercised from that provider during the window of compromise and perform additional diligence for the security of those accounts.  Generally, if only the Recovery Provider's key is compromised, but not the Recovery Provider's other infrastructure around this protocol (e.g. if a key was generated using weak entropy but other operational procedures were sound) then no attack is possible, since an attacker must have both a genuine recovery token and the counter-signing key to take over a user's account. Rotation of the published key is sufficient to restore trust for the purposes of this protocol. Stored recovery tokens do not need to be re-issued.</t>
        <t>If a set of recovery tokens leak from a Recovery Provider, they do not convey any capability without also being countersigned by the Recovery Provider's key, and they by themselves convey no personally identifying information about the account to which they apply.  So long as the Recovery Provider's published key remains secure, leaked recovery tokens do not need to be distrusted or re-issued.  Verification of token bindings and refusal of tokens with a stale <spanx style="verb" xml:space="preserve">issued_time</spanx> prior to saving any recovery token can prevent leaked tokens from being re-added to different accounts under an attacker's control at the same Recovery Provider.</t>
        <t>If an Account Provider loses control of only its token signing key, this conveys limited capabilities to the attacker. It can cause false tokens to be stored by a Recovery Provider, but only at an account it also controls at the Recovery Provider, and will not have the ability to forge the opaque data. To ensure this resistance, the opaque data field should be encrypted using an AEAD mode or other encrypt-then-MAC construction to prevent it from being malleable.</t>
        <t>If an Account Provider loses its data encryption keys, tokens issued under those keys will be unusable.</t>
      </section>
      <!--Key Loss and Compromise -->
      <section title="TLS or HTTPS Certificate Compromise" toc="default">
        <t>This protocol depends on TLS, HTTPS and the Web PKI to bootstrap its self-organizing trust framework using HTTPS to distribute keys.  Because end-users' communication with the network service providers in question, including transmission of credentials and session management material, also are almost always dependent on TLS and the HTTPS Web PKI, there is little value in attempting to eliminate this as part of the trusted computing base for this specification.</t>
        <t>Account and Recovery Providers should be cautious in the management of the root certification authorities they trust when performing configuration discovery operations over HTTPS, should use the latest practical TLS version and should terminate the protocol without user recourse if any errors are encountered. Participants may want to employ additional means to reduce the risk of compromised HTTPS connections that are beyond the scope of this document, such as HTTP Public Key Pinning <xref target="RFC7469" pageno="false" format="default"/> and Certificate Transparency. <xref target="RFC6962" pageno="false" format="default"/></t>
      </section>
      <!--TLS or HTTPS Certificate Compromise -->
      <section title="Token Leakage" toc="default">
        <t>It may be possible that recovery tokens leak to third parties.  Use of the POST method and endpoints which are either well-known or discovered from the configuration are intended as countermeasures.</t>
        <t>Protocol participants should take additional precautions against token leaks in their application-specific logic, such as avoiding moving tokens from POST to GET parameters in cleartext during a login flow prior to saving a token.</t>
        <t>Use of a token binding can reduce these risks.</t>
      </section>
    </section>
    <!--Security Considerations -->
    <section title="Implementation Notes" toc="default">
      <t>This section is non-normative.</t>
      <t>Software platforms may represent Elliptic Curve public keys differently. The configuration encoding required by this specification is the format used by OpenSSL's Elliptic Curve implementation (X9.62 / RFC 3280), which uses the alias "prime256v1" to refer to the NIST secp256r1 curve. Some software only expects a "raw" ECPoint representation as a public key. If your software's EC public key representation is 65 octets long and begins with 0x04, this is a raw ECPoint. Because they are of fixed length, these raw points can be converted to the ASN.1 encoded form required by this specification by simply prefixing the following 26 octets to the buffer:</t>
      <figure title="" suppress-title="false" align="left" alt="" width="" height="">
        <artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
[48, 89, 48, 19, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 8, 42, 134, 72, 206,
61, 3, 1, 7, 3, 66, 0]

</artwork>
      </figure>
    </section>
    <!--Implementation Considerations -->
    <section title="IANA Considerations" toc="default">
      <t>Future revisions to this protocol may use a registry to map supported cryptographic algorithms to the token version indiator.</t>
    </section>
    <!--IANA Considerations -->
    <section title="Acknowledgements" toc="default">
      <t>The author would like to thank Andrey Labunets, Neil Matatall and Patrick Toomey for their valuable contributions.</t>
    </section>
    <!--Acknowledgements -->
  </middle>
  <back>
    <references title="Normative References"><reference anchor="RFC2119" target="http://www.rfc-editor.org/info/rfc2119" quote-title="true"><front><title>Key words for use in RFCs to Indicate Requirement Levels</title><author initials="S." surname="Bradner" fullname="S. Bradner"><organization/></author><date year="1997" month="March"/><abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front><seriesInfo name="BCP" value="14"/><seriesInfo name="RFC" value="2119"/><seriesInfo name="DOI" value="10.17487/RFC2119"/></reference> <reference anchor="RFC3339" target="http://www.rfc-editor.org/info/rfc3339" quote-title="true"><front><title>Date and Time on the Internet: Timestamps</title><author initials="G." surname="Klyne" fullname="G. Klyne"><organization/></author><author initials="C." surname="Newman" fullname="C. Newman"><organization/></author><date year="2002" month="July"/></front><seriesInfo name="RFC" value="3339"/><seriesInfo name="DOI" value="10.17487/RFC3339"/></reference> <reference anchor="RFC3629" target="http://www.rfc-editor.org/info/rfc3629" quote-title="true"><front><title>UTF-8, a transformation format of ISO 10646</title><author initials="F." surname="Yergeau" fullname="F. Yergeau"><organization/></author><date year="2003" month="November"/><abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract></front><seriesInfo name="STD" value="63"/><seriesInfo name="RFC" value="3629"/><seriesInfo name="DOI" value="10.17487/RFC3629"/></reference> <reference anchor="RFC3986" target="http://www.rfc-editor.org/info/rfc3986" quote-title="true"><front><title>Uniform Resource Identifier (URI): Generic Syntax</title><author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee"><organization/></author><author initials="R." surname="Fielding" fullname="R. Fielding"><organization/></author><author initials="L." surname="Masinter" fullname="L. Masinter"><organization/></author><date year="2005" month="January"/><abstract><t>A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource.  This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet.  The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier.  This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme.  [STANDARDS-TRACK]</t></abstract></front><seriesInfo name="STD" value="66"/><seriesInfo name="RFC" value="3986"/><seriesInfo name="DOI" value="10.17487/RFC3986"/></reference> <reference anchor="RFC5246" target="http://www.rfc-editor.org/info/rfc5246" quote-title="true"><front><title>The Transport Layer Security (TLS) Protocol Version 1.2</title><author initials="T." surname="Dierks" fullname="T. Dierks"><organization/></author><author initials="E." surname="Rescorla" fullname="E. Rescorla"><organization/></author><date year="2008" month="August"/><abstract><t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  [STANDARDS-TRACK]</t></abstract></front><seriesInfo name="RFC" value="5246"/><seriesInfo name="DOI" value="10.17487/RFC5246"/></reference> <reference anchor="RFC5480" target="http://www.rfc-editor.org/info/rfc5480" quote-title="true"><front><title>Elliptic Curve Cryptography Subject Public Key Information</title><author initials="S." surname="Turner" fullname="S. Turner"><organization/></author><author initials="D." surname="Brown" fullname="D. Brown"><organization/></author><author initials="K." surname="Yiu" fullname="K. Yiu"><organization/></author><author initials="R." surname="Housley" fullname="R. Housley"><organization/></author><author initials="T." surname="Polk" fullname="T. Polk"><organization/></author><date year="2009" month="March"/><abstract><t>This document specifies the syntax and semantics for the Subject Public Key Information field in certificates that support Elliptic Curve Cryptography.  This document updates Sections 2.3.5 and 5, and the ASN.1 module of "Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile", RFC 3279.  [STANDARDS-TRACK]</t></abstract></front><seriesInfo name="RFC" value="5480"/><seriesInfo name="DOI" value="10.17487/RFC5480"/></reference> <reference anchor="RFC5849" target="http://www.rfc-editor.org/info/rfc5849" quote-title="true"><front><title>The OAuth 1.0 Protocol</title><author initials="E." surname="Hammer-Lahav" fullname="E. Hammer-Lahav" role="editor"><organization/></author><date year="2010" month="April"/><abstract><t>OAuth provides a method for clients to access server resources on behalf of a resource owner (such as a different client or an end-user).  It also provides a process for end-users to authorize third-party access to their server resources without sharing their credentials (typically, a username and password pair), using user-agent redirections.  This document is not an Internet  Standards Track specification; it is published for informational purposes.</t></abstract></front><seriesInfo name="RFC" value="5849"/><seriesInfo name="DOI" value="10.17487/RFC5849"/></reference> <reference anchor="RFC6454" target="http://www.rfc-editor.org/info/rfc6454" quote-title="true"><front><title>The Web Origin Concept</title><author initials="A." surname="Barth" fullname="A. Barth"><organization/></author><date year="2011" month="December"/><abstract><t>This document defines the concept of an "origin", which is often used as the scope of authority or privilege by user agents.  Typically, user agents isolate content retrieved from different origins to prevent malicious web site operators from interfering with the operation of benign web sites.  In addition to outlining the principles that underlie the concept of origin, this document details how to determine the origin of a URI and how to serialize an origin into a string.  It also defines an HTTP header field, named "Origin", that indicates which origins are associated with an HTTP request.   [STANDARDS-TRACK]</t></abstract></front><seriesInfo name="RFC" value="6454"/><seriesInfo name="DOI" value="10.17487/RFC6454"/></reference> <reference anchor="RFC6962" target="http://www.rfc-editor.org/info/rfc6962" quote-title="true"><front><title>Certificate Transparency</title><author initials="B." surname="Laurie" fullname="B. Laurie"><organization/></author><author initials="A." surname="Langley" fullname="A. Langley"><organization/></author><author initials="E." surname="Kasper" fullname="E. Kasper"><organization/></author><date year="2013" month="June"/><abstract><t>This document describes an experimental protocol for publicly logging the existence of Transport Layer Security (TLS) certificates as they are issued or observed, in a manner that allows anyone to audit certificate authority (CA) activity and notice the issuance of suspect certificates as well as to audit the certificate logs themselves.  The intent is that eventually clients would refuse to honor certificates that do not appear in a log, effectively forcing CAs to add all issued certificates to the logs.</t><t>Logs are network services that implement the protocol operations for submissions and queries that are defined in this document.</t></abstract></front><seriesInfo name="RFC" value="6962"/><seriesInfo name="DOI" value="10.17487/RFC6962"/></reference> <reference anchor="RFC7034" target="http://www.rfc-editor.org/info/rfc7034" quote-title="true"><front><title>HTTP Header Field X-Frame-Options</title><author initials="D." surname="Ross" fullname="D. Ross"><organization/></author><author initials="T." surname="Gondrom" fullname="T. Gondrom"><organization/></author><date year="2013" month="October"/><abstract><t>To improve the protection of web applications against clickjacking, this document describes the X-Frame-Options HTTP header field, which declares a policy, communicated from the server to the client browser, regarding whether the browser may display the transmitted content in frames that are part of other web pages.</t></abstract></front><seriesInfo name="RFC" value="7034"/><seriesInfo name="DOI" value="10.17487/RFC7034"/></reference> <reference anchor="RFC7469" target="http://www.rfc-editor.org/info/rfc7469" quote-title="true"><front><title>Public Key Pinning Extension for HTTP</title><author initials="C." surname="Evans" fullname="C. Evans"><organization/></author><author initials="C." surname="Palmer" fullname="C. Palmer"><organization/></author><author initials="R." surname="Sleevi" fullname="R. Sleevi"><organization/></author><date year="2015" month="April"/><abstract><t>This document defines a new HTTP header that allows web host operators to instruct user agents to remember ("pin") the hosts' cryptographic identities over a period of time.  During that time, user agents (UAs) will require that the host presents a certificate chain including at least one Subject Public Key Info structure whose fingerprint matches one of the pinned fingerprints for that host.  By effectively reducing the number of trusted authorities who can authenticate the domain during the lifetime of the pin, pinning may reduce the incidence of man-in-the-middle attacks due to compromised Certification Authorities.</t></abstract></front><seriesInfo name="RFC" value="7469"/><seriesInfo name="DOI" value="10.17487/RFC7469"/></reference> <reference anchor="ISO.8601.1988" quote-title="true"><front><title>Data elements and interchange formats - Information interchange - Representation of dates and times</title><author><organization>International Organization for Standardization</organization></author><date month="June" year="1988"/></front><seriesInfo name="ISO" value="Standard 8601"/></reference> <reference anchor="X9.62" quote-title="true"><front><title>ANS X9.62-2005: The Elliptic Curve Digital Signature Algorithm (ECDSA)</title><author><organization>American National Standards Institute (ANSI)</organization></author><date year="2005"/></front></reference></references>
    <section title="Initial Algorithm Registry Contents" toc="default">
      <texttable style="all" title="" suppress-title="false" align="center">
        <preamble>properties</preamble>
        <ttcol align="left">value</ttcol>
        <ttcol align="left">algorithm</ttcol>
        <ttcol align="left">references</ttcol>
        <c>0</c>
        <c>ECDSA-SHA256 on the secp256r1 named curve</c>
        <c><xref target="X9.62" pageno="false" format="default"/> <xref target="RFC5480" pageno="false" format="default"/> </c>
      </texttable>
    </section>
  </back>
</rfc>
